/*
 * The GNU Flex program should be used to process this file.
 *
 * The code in this file can be used by the GNU Flex program and the GNU C++ compiler, to implement
 * a very basic Lexical Scanner. The code which is contained within this file, implements the
 * Lexical Scanner using the C++ programming language. One of the consequences of it being
 * implemented using the C++ programming language, is that it needs to be processed appropriately.
 * The following point(s) should be taken into account when using the GNU Flex program to process
 * this file.
 *
 *   - Use any one of the following commands to process this file;
 *
 *       > flex   --verbose       --outfile=./SimpleScanner.cpp ./SimpleScanner.ll
 *       > flex   --verbose --c++ --outfile=./SimpleScanner.cpp ./SimpleScanner.ll
 *       > flex++ --verbose       --outfile=./SimpleScanner.cpp ./SimpleScanner.ll
 *
 * Note 1) : If the first incarnation of the command is used, then you may also need to specify the
 *           following option below;
 *
 *             %option c++
 *
 * Note 2) : The first incarnation of the command can also be used to process this file, if the code
 *           in this file implements a Scanner using the C programming language.
 *
 * Note 3) : The flex++ version of the GNU Flex program should be used
 *
 * If it is able to successfully process this file, then the GNU Flex program should generate one of
 * the following two output files;
 *
 *   - lex.yy.c   # If the Scanner has been implemented in C.
 *   - lex.yy.cc  # If the Scanner has been implemented in C++.
 */


%{
// %option noyywrap
// %option c++
// %option header-file="SimpleScanner.yy.hpp"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>

#include <SimpleParser.tab.hpp>


using std::string;
using std::cout;
using std::endl;

// using token = yy::parser::token;


/*
 * A Lexer/Scanner/Tokeniser which is generated by GNU Flex can be run in one of two modes;
 *
 *   - in standalone mode
 *   - invoked by a Parser
 *
 * If the Lexer which is defined in this file is to be run in standalone mode, then define the
 * Preprocessor macro STANDALONE_SCANNER.
 */

#define STANDALONE_SCANNER  1
#undef  STANDALONE_SCANNER

#ifdef STANDALONE_SCANNER

#define UUID                100
#define COMMAND_ECHO_UUID   101
#define COMMAND_CREATE_NODE 102
#define COMMAND_CONNECT     103
#define COMMAND_DISCONNECT  104
#define COMMAND_EXIT        105
#define COMMAND_QUIT        106
#define COMMAND_HELP        107
#define VARIABLE            800
#define LPAREN              108
#define RPAREN              109
#define RETURN_VALUE(returnCode)

#else

// Include the Token type (aka Token kind) definitions produced by Bison.

#include "SimpleParser.tab.hpp"

#endif


#ifdef STANDALONE_SCANNER

#else
#define RETURN_VALUE(returnCode) ({return(returnCode);})
#endif
%}

%option header-file="lex.yy.hpp"
%option yylineno


%%

    /*
     * Expression for defining valid UUID values.
     *
     * Example of a valid UUID value;
     *
     *   028F37D3-6398-773F-8CF9-3829F7D3AA02
     */

[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}  {

    cout << endl;
    cout << "Scanner/Tokenizer has encountered a UUID" << endl;
	cout << "Length of UUID in chars                = "             << strlen(yytext) << endl;
	cout << "Address in memory of UUID              = "             << & yytext       << endl;
	cout << "Value of UUID Token type               = "             << yy::parser::token::UUID           << endl;
	cout << "UUID encountered                       : "             << yytext         << endl;
    cout << endl;

    // Where does the following value get returned to?

    // RETURN_VALUE(UUID);

    // This following line of code will cause the yylex function to return.

    // return(UUID);
}

"echoUUID"  {

    cout << endl;
    cout << "Scanner/Tokenizer has encountered the token : echoUUID" << endl;
	cout << "Length of token in chars               = " << strlen(yytext) << endl;
	cout << "Address in memory of token             = " << & yytext << endl;
	cout << "Value of COMMAND_ECHO_UUID Token type  = " << yy::parser::token::COMMAND_ECHO_UUID << endl;
    cout << endl;

    // Where does the following value get returned to?

    // RETURN_VALUE(COMMAND_ECHO_UUID);

    return(yy::parser::token::COMMAND_ECHO_UUID);
}

"createNode" {

    cout << endl;
    cout << "Scanner/Tokenizer has encountered the token : createNode" << endl;
	cout << "Length of token in chars                = " << strlen(yytext) << endl;
	cout << "Address in memory of token              = " << & yytext << endl;
	cout << "Value of COMMAND_CREATE_NODE Token type = " << yy::parser::token::COMMAND_CREATE_NODE << endl;
    cout << endl;

    // Where does the following value get returned to?

    // RETURN_VALUE(COMMAND_CREATE_NODE);

    return(yy::parser::token::COMMAND_CREATE_NODE);
}

"connect"  {

    cout << endl;
    cout << "Scanner/Tokenizer has encountered the token : connect" << endl;
	cout << "Length of token in chars               = " << strlen(yytext) << endl;
	cout << "Address in memory of token             = " << & yytext << endl;
	cout << "Value of COMMAND_CONNECT Token type    = " << yy::parser::token::COMMAND_CONNECT << endl;
    cout << endl;

    return(yy::parser::token::COMMAND_CONNECT);
}

"disconnect"  {

    cout << endl;
    cout << "Scanner/Tokenizer has encountered the token : disconnect" << endl;
	cout << "Length of token in chars               = " << strlen(yytext) << endl;
	cout << "Address in memory of token             = " << & yytext << endl;
	cout << "Value of COMMAND_DISCONNECT Token type = " << yy::parser::token::COMMAND_DISCONNECT << endl;
    cout << endl;

    return(yy::parser::token::COMMAND_DISCONNECT);
}

"help"  {

    cout << endl;
    cout << "Scanner/Tokenizer has encountered the token : help" << endl;
	cout << "Length of token in chars               = " << strlen(yytext) << endl;
	cout << "Address in memory of token             = " << & yytext << endl;
	cout << "Value of COMMAND_HELP Token type       = " << yy::parser::token::COMMAND_HELP << endl;
    cout << endl;

    return(yy::parser::token::COMMAND_HELP);
}

"exit"           {

    return(yy::parser::token::COMMAND_EXIT);
}

"quit"           {

    // Instruct yylex to exit with a return value of COMMAND_QUIT.

    return(yy::parser::token::COMMAND_QUIT);
}

"("              {return(yy::parser::token::LPAREN);}
")"              {return(yy::parser::token::RPAREN);}
[,;]             {return(yytext[0]);}
"//".*           /* Don't process C++ style line comments.
                    Recall that flex's default action is to discard any characters which match. */
[ \t\n]          ;
.                {
    cout << "The Scanner/Tokenizer has encountered the following character which is either ";
    cout << "invalid, or does not form part of a keyword : " << yytext[0] << endl;
}

    /*
     * Be very careful that this rule doesn't override or clobber other rules.
     *
     * Maybe put it near the end to avoid this situation.
     */

[_a-zA-Z]{1}[_a-zA-Z0-9]{9} {

    cout << endl;
    cout << "Scanner/Tokenizer has encountered the token : Valid variable name" << endl;
	cout << "Length of token in chars                = " << strlen(yytext) << endl;
	cout << "Address in memory of token              = " << & yytext << endl;
	cout << "Value of VARIABLE Token type            = " << yy::parser::token::VARIABLE << endl;
    cout << endl;

    // Where does the following value get returned to?

    // RETURN_VALUE(COMMAND_CREATE_NODE);

    return(yy::parser::token::VARIABLE);
}

%%

// The function yywrap will be called by the Lexer when the input is exhausted.
//
// Return 0 if more processing is required or 1 otherwise.

int
yyFlexLexer::yywrap
(
)
{
    const
    string   nameMethod = "yywrap";


    // cout << nameMethod << " : Enter" << endl;

    cout << "Function " << nameMethod << " has been invoked." << endl;

    // cout << nameMethod << " : Exit" << endl;

	return(1);
}


// -------------------------------------------------------------------------------------------------
// Forward declaration of helper functions.
// -------------------------------------------------------------------------------------------------

void
setupRoutine
(
 int         *,
 int         *,
 int         *,
 yyFlexLexer *
);


void
displayStartupMessage
(
 void
);

